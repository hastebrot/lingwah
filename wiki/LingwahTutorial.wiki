#summary Lingwah Tutorial

= Lingwah Tutorial =

In this tutorial we will use a classic example, a calculator, to show how lingwah's declarative API can be used to construct a parser.

Our calculator should be able to:

 * support calculation of decimal numbers.
 * support Operators such as '+', '-', '{{{*}}}', '/'.
 * group expressions with '(' and ')'.
 * allow java style inline comment enclosed by "/{{{*}}}" and "{{{*}}}/".
 * allow the use of whitespace.  So "1+2" is equivalent to "1 + 2".
 
In this tutorial we will develop a class named 'Calculator' with a single static method that parses an expression and returns the decimal value of the expression.
Here is an example of how our calculator will work:
{{{
// prints "answer=2082.5615313302951609592032881793"
System.out.println("answer="+Calculator.parse("(6543.56 - 1)/ 3.14159265/*Pi*/");
}}}

= The Lingwah Way = 

Lingwah is used in two steps:
 # Parse some text and create an AST (Abstract Syntax Tree). 
   An AST is an object that represents the structure of the parsed text.
 # Navigate and process the AST to create a result from the parsed text.
 
== Lingwah Grammars ==   
Lingwah needs a grammar definition in order to parse text.
In lingwah a grammar definition is represented by an instance of the Grammar class.
The details of creating a lingwah grammar are covered later.
   
== Lingwah ASTs ==   
In lingwah an AST is represented by an instance the Match class.
An instance of Match may include: 	
 * an error message if there was no match.
 * a reference to the Parser that found the Match (the Parser reference is used to identify the Grammar element associated which the Match)
 * a list of sub-Matches that describes the sub-elements of the matched grammar element.
The details of how to navigate and process a lingwah Match are covered later.    

== Creating the Calculator == 	
To create our Calculator we will be required to create three classes:
 # A subclass of the lingwah Grammar class that defines the calculator grammar.
 # A subclass of the lingwah MatchProcessor class that processes Match instances.   
 # The Calculator class itself, which just provides a convenient API parsing text and getting a result.   

= The Calculator Grammar =
  
To understand how to specify a grammar using parser combinators it helps to have a passing knowledge of [http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form Extended Backus-Naur Form (EBNF)], a way of specifying how a language will look. 
Our calculator language is described by the following EBNF:

{{{
inline_comment = "/*", {?any_character?}, "/*"; 
blank	= ' ' | '\t' | '\n' | '\r';
ws	= (blank, {blank}) | inline_comment;
digit = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';
number = digit, { digit };
decimal = [ '-' ], (number, ['.', [number]] | '.', number);
addition = expr, [ws], '+', [ws], expr;
subtraction = expr, [ws], '-', [ws], expr;
multiplication = (expr, [ws], '*', [ws], expr) | (expr, [ws], expr);
division = expr, [ws], '\', [ws], expr;
group = '(', [ws], expr, [ws], ')';
expr = decimal | addition | subtraction | multiplication | division | group;
}}}


= Defining a Grammar in Lingwah =

Here is how the EBNF grammar from the previous section is written in Java using the lingwah API:
{{{
import com.googlecode.lingwah.Grammar;
import com.googlecode.lingwah.Parser;
import com.googlecode.lingwah.parser.ParserReference;

public class CalculatorGrammar extends Grammar {
	public final Parser inline_comment = seq(str("/*"), anyChar(), str("/*")); 
	public final Parser ws	= cho(oneOrMore(regex("[ \t\n\f\r]")), inline_comment);
	public final Parser digit = regex("[0-9]");
	public final Parser number = oneOrMore(digit);
	public final Parser decimal = seq(opt(str('-')), seq(number, opt(seq(str('.'), number))));
	public final ParserReference expr = ref();
	public final Parser addition = seq(expr, str('+'), expr).sep(opt(ws));
	public final Parser subtraction = seq(expr, str('-'), expr).sep(opt(ws));
	public final Parser multiplication = seq(expr, str('*'), expr).sep(opt(ws));
	public final Parser division = seq(expr, str('\\'), expr).sep(opt(ws));
	public final Parser group = seq(str('('), expr, str(')')).sep(opt(ws));
	{
		expr.set(cho(decimal, addition, subtraction, multiplication, division, group));
	}
	
	private CalculatorGrammar() {
		init();
	}
	public static final CalculatorGrammar INSTANCE= new CalculatorGrammar(); 
}
}}}

Note the following features of this class:
 * For each element of the EBNF grammar there is an equivalent lingwah Parser definition.
 	The lingwah Grammer class includes many functions for creating terminal Parsers and many types of non-terminal parsers.
 	The lingwah Grammer class includes functions for creating all types of non-terminal rules allowed in EBNF such as sequences, choices, and repetitions.
 * The expr rule is recursive.  That is, the expr rule uses rules which in turn use the expr rule.
    In order to define recursive rules a 'rule reference' is created using the ref() method.
    Later, after all the dependent rules have been defined the reference may be set using the reference's set method.
 * A constructor is created at the bottom of the class definition which calls the Grammar.init() method.
 	It is important that the constructor be declared *at the bottom* of the class and that the init method is called.
 	The init method is responsible for initialing all the declared Parsers, and this can only be done *after* the parsers have been created.
 * For convenience, rules can be defined with short names like 'seq' instead of 'sequence'.
 	However, if you prefer you may use the longer names.
 	The following short names are the most commonly used:
 	<table border="1">
 	<thead><td>*long name*</td><td>*short name*</td></thead>
 	<tr><td>sequence</td><td>seq</td></tr>
 	<tr><td>choice</td><td>choice</td></tr>
 	<tr><td>repetition</td><td>rep, or zeroOrMore</td></tr>
 	<tr><td>optional</td><td>opt</td></tr>
 	<tr><td>reference</td><td>reference</td></tr>
 	<tr><td>separatedBy</td><td>sep</td></tr>
 	</table>
 * When supporting whitespace, instead of polluting a rule definition with a lot whitespace rules we can often just use the 'separatedBy' method to add support for whitespace to a rule.
 	For instance, these two definitions are equivalent:
	{{{ 
	Parser subtraction = seq(expr, str('-'), expr).sepBy(opt(ws));
	Parser subtraction = seq(expr, opt(ws), str('-'), opt(ws), expr); }}}
	}}}
 * Lingwah includes a regular expression parser that is very convenient for declaring terminal rules.
 	For instance, this EBNF...
 	{{{ digit = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'; }}}
 	...can be written in lingwah like this...
 	{{{ Parser digit = regex("[0-9]"); }}}

= Processing an AST in Lingwah =

=


= Finally, create the Calulator = 

Now that we have defined our Grammar and created a corresponding MatchProcessor it is a simple matter to create our Calculator class:

{{{
import java.math.BigDecimal;
import com.googlecode.lingwah.*;

public class Calculator {
	static final Parser PARSER= CalculatorGrammar.INSTANCE.expr;
	public static BigDecimal parse(String expression) 
	{
		ParseResults parseResults= ParseContext.parse(PARSER, expression);
		if (!parseResults.success())
			throw parseResults.getError();
		return new CalculatorProcessor().process(parseResults.getLongestMatch());
	}
}
}}} 







