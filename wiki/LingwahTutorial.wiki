#summary Lingwah Tutorial

= Lingwah Tutorial =

In this tutorial we will use a classic example, a calculator, to show how lingwah's declarative API can be used to construct a parser.

Our calculator should be able to:

 * support calculation of decimal numbers.
 * support Operators such as '+', '-', '{{{*}}}', '/'.
 * group expressions with '(' and ')'.
 * allow java style inline comment enclosed by "/{{{*}}}" and "{{{*}}}/".
 * allow the use of whitespace.  So "1+2" is equivalent to "1 + 2".
 
In this tutorial we will develop a class named 'Calculator' with a single static method that parses an expression and returns the decimal value of the expression.
Here is an example of how our calculator will work:
{{{
// prints "answer=2082.5615313302951609592032881793"
System.out.println("answer="+Calculator.parse("(6543.56 - 1)/ 3.14159265/*Pi*/");
}}}

= The Lingwah Way = 

Lingwah is used in two steps:
 # Parse some text and create an AST (Abstract Syntax Tree). 
   An AST is an object that represents the structure of the parsed text.
 # Navigate and process the AST to create a result from the parsed text.
 
== Lingwah Grammars ==   
Lingwah needs a grammar definition in order to parse text.
In lingwah a grammar definition is represented by an instance of the Grammar class.
The details of creating a lingwah grammar are covered later.
   
== Lingwah ASTs ==   
In lingwah an AST is represented by an instance the Match class.
An instance of Match may include: 	
 * an error message if there was no match.
 * a reference to the Parser that found the Match (the Parser reference is used to identify the Grammar element associated which the Match)
 * a list of sub-Matches that describes the sub-elements of the matched grammar element.
The details of how to navigate and process a lingwah Match are covered later.    

== Creating the Calculator == 	
To create our Calculator we will be required to create three classes:
 # A subclass of the lingwah Grammar class that defines the calculator grammar.
 # A subclass of the lingwah MatchProcessor class that processes Match instances.   
 # The Calculator class itself, which just provides a convenient API parsing text and getting a result.   

= The Calculator Grammar =
  
To understand how to specify a grammar using parser combinators it helps to have a passing knowledge of [http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form Extended Backus-Naur Form (EBNF)], a way of specifying how a language will look. 
Our calculator language is described by the following EBNF:

{{{
inline_comment = "/*", {?any_character?}, "/*"; 
blank	= ' ' | '\t' | '\n' | '\r';
ws	= (blank, {blank}) | inline_comment;
digit = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';
number = digit, { digit };
decimal = [ '-' ], (number, ['.', [number]] | '.', number);
addition = expr, [ws], '+', [ws], expr;
subtraction = expr, [ws], '-', [ws], expr;
multiplication = (expr, [ws], '*', [ws], expr) | (expr, [ws], expr);
division = expr, [ws], '\', [ws], expr;
group = '(', [ws], expr, [ws], ')';
expr = decimal | addition | subtraction | multiplication | division | group;
}}}


= Defining a Grammar in Lingwah =

Here is how the EBNF grammar from the previous section is written in Java using the lingwah API:
{{{
import com.googlecode.lingwah.Grammar;
import com.googlecode.lingwah.Parser;
import com.googlecode.lingwah.parser.ParserReference;

public class CalculatorGrammar extends Grammar {
	public final Parser inline_comment = seq(str("/*"), zeroOrMore(anyChar()), str("*/")); 
	public final Parser ws	= oneOrMore(cho(oneOrMore(regex("[ \t\n\f\r]")), inline_comment));
	public final Parser digit = regex("[0-9]");
	public final Parser number = oneOrMore(digit);
	public final Parser decimal = seq(opt(str('-')), seq(number, opt(seq(str('.'), number))));
	public final ParserReference expr = ref();
	public final Parser addition = seq(expr, str('+'), expr).separatedBy(opt(ws));
	public final Parser subtraction = seq(expr, str('-'), expr).separatedBy(opt(ws));
	public final Parser multiplication = seq(expr, str('*'), expr).separatedBy(opt(ws));
	public final Parser division = seq(expr, str('/'), expr).separatedBy(opt(ws));
	public final Parser group = seq(str('('), expr, str(')')).separatedBy(opt(ws));
	{
		expr.set(cho(decimal, addition, subtraction, multiplication, division, group));
	}
	
	private CalculatorGrammar() {
		init();
	}
	public static final CalculatorGrammar INSTANCE = new CalculatorGrammar();
}
}}}

Note the following features of this class:
 * For each element of the EBNF grammar there is an equivalent lingwah Parser definition.
 	The lingwah Grammer class includes many functions for creating terminal Parsers and many types of non-terminal parsers.
 	The lingwah Grammer class includes functions for creating all types of non-terminal rules allowed in EBNF such as sequences, choices, and repetitions.
 * The expr rule is recursive.  That is, the expr rule uses rules which in turn use the expr rule.
    In order to define recursive rules a 'rule reference' is created using the ref() method.
    Later, after all the dependent rules have been defined the reference may be set using the reference's set method.
 * A constructor is created at the bottom of the class definition which calls the Grammar.init() method.
 	It is important that the constructor be declared *at the bottom* of the class and that the init method is called.
 	The init method is responsible for initialing all the declared Parsers, and this can only be done *after* the parsers have been created.
 * For convenience, rules can be defined with short names like 'seq' instead of 'sequence'.
 	However, if you prefer you may use the longer names.
 	The following short names are the most commonly used:
 	<table border="1">
 	<thead><td>*long name*</td><td>*short name*</td></thead>
 	<tr><td>sequence</td><td>seq</td></tr>
 	<tr><td>choice</td><td>choice</td></tr>
 	<tr><td>repetition</td><td>rep, or zeroOrMore</td></tr>
 	<tr><td>optional</td><td>opt</td></tr>
 	<tr><td>reference</td><td>reference</td></tr>
 	<tr><td>separatedBy</td><td>sep</td></tr>
 	</table>
 * When supporting whitespace, instead of polluting a rule definition with a lot whitespace rules we can often just use the 'separatedBy' method to add support for whitespace to a rule.
 	For instance, these two definitions are equivalent:
	{{{ 
	Parser subtraction = seq(expr, str('-'), expr).sepBy(opt(ws));
	Parser subtraction = seq(expr, opt(ws), str('-'), opt(ws), expr); }}}
	}}}
 * Lingwah includes a regular expression parser that is very convenient for declaring terminal rules.
 	For instance, this EBNF...
 	{{{ digit = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'; }}}
 	...can be written in lingwah like this...
 	{{{ Parser digit = regex("[0-9]"); }}}

= Processing an AST in Lingwah =

As mentioned previously, lingwah parses text and creates an AST (and an AST is represented by a Match).
Lingwah provides a convenient API for processing ASTs, the MatchProcessor API.
It is not necessary to use this processor API, ASTs may be navigated and processed in many ways.
The MatchProcessor API is convenient becauses it provides functionality which is commonly needed when processing an AST, 
such as managing the navigation of nodes in the AST, caching results associated with nodes, etc.



== The MatchProcessor API ==

Lingwah MatchProcessor API is an implementation of the [http://en.wikipedia.org/wiki/Visitor_pattern Vistor pattern], and provides a convenient API for processes Match ASTs.

The Match class has a method called accept(MatchProccessor) which accepts a MatchProcessor, calls the MatchProcessor's 
process methods, optionally passes the process to all of its children (and so on and so on), and then finally calls the 
MatchProcessor's complete method. 

Here is the interface that is implemented by all MatchProcessors:
{{{
public interface MatchProcessor {
	/**
	 * Invoked when visiting a node in the tree
	 * @return true if children of this node should be visited
	 */
	public boolean process(Match node);
	
	/**
	 * Invoked after invoking the visit method and visiting all children nodes   
	 */
	public void complete(Match node);
}
}}}

A MatchProcessor is very much like a Visitor, except it has two methods:
 * the process method, like the visit method in the Visitor pattern, is invoked when visiting a node in the AST tree, and
 * the complete method, which is invoked after invoking the visit method and visiting all children nodes.

The complete method is convenient for computing results which require children nodes to be processed before a result can be calculated.

Lingwah has a default implementation of this interface named AbstractProcessor that provides a convenient implementation of the MatchProcessor interface.


A MatchProcessor is like a visitor, it navigates an AST tree and calls the process and complete methods for each node in the tree.
The base processor class has a method named process(Match).
When the process method is invoked the 


Below is shown the processor for out calculator example.
The rest of this section will explain how the processor works.
{{{
import java.math.*;
import java.util.List;

import com.googlecode.lingwah.*;

@Processes(CalculatorGrammar.class)
public class CalculatorProcessor extends AbstractProcessor {
	
	static final CalculatorGrammar grammar= CalculatorGrammar.INSTANCE;
	
	public void completeAddition(Match expr) {
		List<Match> children= expr.getChildrenByType(grammar.expr);
		BigDecimal left= getResult(children.get(0));
		BigDecimal right= getResult(children.get(1));
		putResult(left.add(right));
	}
	public void completeSubtraction(Match expr) {
		List<Match> children= expr.getChildrenByType(grammar.expr);
		BigDecimal left= getResult(children.get(0));
		BigDecimal right= getResult(children.get(1));
		putResult(left.subtract(right));
	}
	public void completeMultiplication(Match expr) {
		List<Match> children= expr.getChildrenByType(grammar.expr);
		BigDecimal left= getResult(children.get(0));
		BigDecimal right= getResult(children.get(1));
		putResult(left.multiply(right));
	}
	public void completeDivision(Match expr) {
		List<Match> children= expr.getChildrenByType(grammar.expr);
		BigDecimal left= getResult(children.get(0));
		BigDecimal right= getResult(children.get(1));
		putResult(left.divide(right, 28, RoundingMode.HALF_UP));
	}
	public void completeGroup(Match expr) {
		putResult(getResult(expr.getChildByType(grammar.expr)));
	}
	public void completeDecimal(Match expr) {
		putResult(new BigDecimal(expr.getText()));
	}
	public void completeExpr(Match expr) {
		putResult(getResult(expr.getChildren().get(0)));
	}

	public static BigDecimal process(ParseResults results) {
		return new CalculatorProcessor().getResult(results.getLongestMatch());
	}

}
}}}

== Method names ==

A processor is like a vistor, it navigates an AST tree and calls the process and complete methods for each node in the tree.
The base processor class has a method named process(Match).
When the process method is invoked the 


Let's examine the first method, completeAddition, and explain how it works  
	public void completeAddition(Match expr) {
		List<Match> children= expr.getChildrenByType(grammar.expr);
		BigDecimal left= getResult(children.get(0));
		BigDecimal right= getResult(children.get(1));
		putResult(left.add(right));
	}
 


=


= Finally, create the Calulator = 

Now that we have defined our Grammar and created a corresponding MatchProcessor it is a simple matter to create our Calculator class:

{{{
public class Calculator {
	static final Parser PARSER= CalculatorGrammar.INSTANCE.expr;
	public static BigDecimal parse(String expression) 
	{
		ParseResults parseResults= ParseContext.parse(PARSER, expression);
		if (!parseResults.success())
			throw parseResults.getError();
		return CalculatorProcessor.process(parseResults);
	}
}
}}} 

This class simply performs the two steps that comprise the typical linwah workflow, parsing some text and then processing the AST.
First the ParseContext.parse method (a convenience method) is invoked to parse an expression.
Then the CalculatorProcessor.process is invoked to calculate a value from the results.


That's it!
Welcome to lingwah.






